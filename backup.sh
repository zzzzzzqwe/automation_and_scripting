# Руководство по запуску:
# Делаем скрипт исполняемым - chmod +x backup.sh
# Запускаем используя ./backup.sh "путь к файлу для резерва" "путь бэкапа"
# В случае если не указывается директория для хранения бэкапа, команду запуска скрипта необходимо запускать через sudo, так как создается директория /backup в root

#!/bin/bash
# Строка выше - shebang. При запуске ./backup.sh ядро Linux смотрит на первую строку: если она начинается с #!, то оно запускает указанный интерпретатор и отдаёт ему файл скрипта. Здесь - Bash.

# Проверка, что первый аргумент (директория для архивирования) не пустая.
if [ -z "$1" ]; then
  echo "Ошибка: не указан путь к директории для резервного копирования."
  exit 1
fi
# Присвоение переменных
# Директория, которую нужно архивировать
SOURCE_DIR="$1"
# Директория бэкапа, если не указана - используем /backup
BACKUP_DIR="${2:-/backup}"
# Текущее время
DATE=$(date +%Y-%m-%d_%H-%M-%S)
# Имя архива
ARCHIVE_NAME="backup_${DATE}.tar.gz"

# Проверяем, существует ли исходная директория
if [ ! -d "$SOURCE_DIR" ]; then
  echo "Ошибка: директория '$SOURCE_DIR' не существует."
  exit 1
fi

# Проверяем, существует ли директория для сохранения бэкапов
if [ ! -d "$BACKUP_DIR" ]; then
  echo "Директория для сохранения '$BACKUP_DIR' не существует. Создаем директорию."
  mkdir -p "$BACKUP_DIR" || { echo "Не удалось создать директорию $BACKUP_DIR"; exit 1; }
fi

# Создаем архив
tar -czf "$BACKUP_DIR/$ARCHIVE_NAME" -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")"

# Проверяем успешность выполнения, $? содержит код возврата последней выполненной команды, в данном случае tar, сооответственно так проверяем создался ли архив
if [ $? -eq 0 ]; then
  echo "Резервная копия успешно создана: $BACKUP_DIR/$ARCHIVE_NAME"
else
  echo "Ошибка при создании архива."
  exit 1
fi